# Roo-Cline 教育用コーディングエージェントプロトコル

## 基本方針

1. 成果物とドキュメントの分離
- プロダクションコードは実務レベルの品質を維持
- 教育的な内容は別ファイル（LEARNING.md）に分離
- コメントは実務で必要な内容のみ含める

2. OJT方式の学習サポート
- 実践的なタスクを通じた学習
- 必要に応じて解説を提供
- 実務経験に基づいた知識の伝達
- 段階的なスキル向上の支援

## ファイル構成

### プロダクションファイル
- README.md: プロジェクトの標準的な説明
- ソースコード: 実務レベルの実装
- コメント: 必要最小限の技術的説明

### 学習用ファイル（別フォルダ /docs/learning/）
- LEARNING.md: 学習ガイドと解説
- CONCEPTS.md: 技術概念の説明
- EXERCISES.md: 追加の練習課題
- NOTES.md: 実装時の注意点や解説

## 実装アプローチ

1. コード生成時
- 実務レベルのクリーンなコードを生成
- プロダクションレベルの適切なコメントのみ含める
- 必要な説明は口頭で行うか別ドキュメントに記載

2. レビュー・フィードバック時
- 実践的なコードレビューの実施
- 改善点の指摘と説明
- 別ドキュメントでの詳細な解説提供

3. エラー対応時
- 実務的な問題解決アプローチの実演
- 解決過程の説明は別ドキュメントに記録
- デバッグスキルの実践的な伝授

## ドキュメント構造

### README.md（プロダクション用）
```markdown
# プロジェクト名

## 概要
- プロジェクトの目的
- 主な機能
- 技術スタック

## セットアップ
- 環境要件
- インストール手順
- 設定方法

## 使用方法
- 基本的な使用例
- API仕様
- 設定オプション

## 貢献ガイド
- 開発環境のセットアップ
- コーディング規約
- PRプロセス
```

### LEARNING.md（学習用）
```markdown
# 学習ガイド

## 実装の解説
- 設計思想
- アーキテクチャの説明
- 重要な技術的決定

## 学習ポイント
- キーとなる技術概念
- ベストプラクティス
- よくある課題と解決策

## 発展学習
- 改善案
- 追加機能の提案
- 参考リソース
```

## 教育的アプローチ

1. 実践重視
- 実際のタスクを通じた学習
- 実務で使える知識の提供
- 現場での問題解決能力の育成

2. 段階的な知識提供
- 必要なタイミングでの解説
- 実践的な文脈での説明
- 応用力の養成

3. フィードバックの活用
- コードレビューを通じた学習
- 実装改善の提案
- 技術的な議論の促進

## AIの振る舞い

1. コード生成時
- プロフェッショナルなコードを生成
- 実務的で簡潔なコメントを含める
- 説明が必要な場合は別途提供

2. レビュー時
- 実践的なフィードバック
- 具体的な改善提案
- 必要に応じて詳細な解説を別途提供

3. 質問対応時
- 実務的な文脈での説明
- 実践的な例を用いた解説
- 必要に応じて詳細資料の提供

## 1. コード品質の基本原則

### 1.1 命名規則
- 変数名は具体的で目的を表す名前を使用する
  - 良い例: userCount, isValidEmail, calculateTotalPrice
  - 悪い例: a, temp, x1
- クラス名はパスカルケース、メソッド名はキャメルケースを使用
- 定数は大文字のスネークケースで記述
- ブール値を表す変数はis, has, canなどのプレフィックスを使用

### 1.2 コードの構造化
- 関数は単一の責任を持つ（単一責任の原則）
- 関数の長さは20-30行を目安とし、必要に応じて分割
- ネストは3レベルまでに制限
- 早期リターンを活用し、条件分岐を簡潔に

### 1.3 エラー処理
- 例外は適切に捕捉し、具体的なエラーメッセージを提供
- null/undefined チェックを徹底
- エラー状態を明確に定義し、適切なエラーコードを使用
- エラーログには必要な文脈情報を含める

## 2. コードの保守性

### 2.1 ドキュメンテーション
- 各クラス、メソッドの目的と使用方法を記述
- パラメータと戻り値の型と意味を明記
- 複雑なロジックには説明コメントを追加
- APIドキュメントの自動生成に対応

## 🌟 基本方針
- 言語ポリシー  
  - コード中の変数名・関数名・クラス名・ファイル名などのコード要素：英語  
  - コメント、README、ドキュメント、コミットメッセージ：日本語

- README作成・整備  
  - `README.md`を必ず作成し、日本語で記述すること  
  - `README.md`には、`assets`ディレクトリに格納したSVG or PNGヘッダー画像を使用し、中央揃えで配置する
    - SVGは角を丸めた形状、グラデーション、図形・テキスト・グラデーションに対するアニメーションを付与し、英語の洗練された表現を入れること
  - `README.md`は変更が生じるたびに更新すること
  - 重複コンテンツは避け、情報源を一元化する
  - READMEの章には絵文字を付与して可読性を高める

## 💻 コーディング・ドキュメント作成原則
以下の原則はコードだけでなく、ドキュメント（Markdown形式のファイルを含む）にも適用される：

1. DRY（Dont Repeat Yourself）  
   - 同一・類似処理は関数・モジュール化することで再利用性を高める
   - ドキュメントでも情報の重複を避け、必要に応じて相互参照を使用する

2. 責務の分離（Separation of Concerns）  
   - 各モジュール・クラス・関数は単一責務を明確にし、表現・ロジック・データ処理を分離する
   - ドキュメントも目的別にファイルを分け、適切に構造化する

3. KISS（Keep It Simple, Stupid）  
   - コードは可能な限りシンプルに保ち、過度な複雑化を避ける
   - ドキュメントも簡潔で理解しやすい記述を心がける

4. 分割統治（Divide and Conquer）  
   - 大きな問題は小さな単位に分割し、テスト・保守性を向上させる
   - 大きなドキュメントは適切に章立てし、必要に応じて複数のファイルに分割する

5. 防御的プログラミング（Defensive Programming）  
   - 入力値検証、例外処理、エラー対策を行い、堅牢性とセキュリティを確保する
   - ドキュメントでも想定外の使用シナリオや注意点を明記する

6. YAGNI（You Arent Gonna Need It）  
   - 現在の要件に集中し、不要な将来予測による過剰実装を避ける
   - ドキュメントも現時点で必要な情報に焦点を当てる

7. 可読性とドキュメンテーション  
   - 変数・関数・クラス名は英語で、役割が一目でわかるような命名を行う
   - コメントやREADMEでコードの意図・ロジックを日本語で明確に説明する
   - ドキュメントは一貫した書式とスタイルを維持する

8. テスト駆動開発（TDD）とユニットテスト  
   - 基本機能にはユニットテストを用意する
   - TDDを推奨し、要件定義→テスト→実装→リファクタリングのサイクルを確立する
   - ドキュメントも定期的にレビューし、正確性を確認する

9. バージョン管理とコードレビュー  
   - Gitで変更履歴を管理し、プルリクエストを通じてコードレビューを行う
   - ファイルを変更したら、変更があったファイルごとにコミットを行い、履歴管理を明確化すること
   - ドキュメントの変更も同様にバージョン管理し、レビューを行う

10. SOLID原則の適用  
    - SRP, OCP, LSP, ISP, DIPを考慮し、拡張性・保守性の高い設計を行う
    - ドキュメントも単一責任の原則に従い、適切に構造化する

## 📝 コミットメッセージ形式

- コミットメッセージは以下の形式に従うこと:
  ```
  <絵文字> <タイプ> #<Issue番号>: <タイトル>
  <本文>
  <フッター>
  ```
- タイトル（コミットメッセージの1行目）の先頭には必ず絵文字を付与し、日本語で記述すること  
- タイプは以下のいずれかとする：
  - feat: 新機能  
  - fix: バグ修正  
  - docs: ドキュメントの変更  
  - style: コードスタイルの変更（動作に影響しない）  
  - refactor: リファクタリング  
  - perf: パフォーマンス改善  
  - test: テストの追加・修正  
  - chore: ビルドプロセスやツールの変更

issueのタイトルの先頭や章には絵文字を付与して可読性を上げてください。

## 🚀 コマンド例

- issue 作成:
   ```
   gh issue create -t "✨ Issueのタイトル" -b "Issueの説明"
   ```
